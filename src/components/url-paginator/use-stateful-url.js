import React, { useMemo, useEffect } from 'react';
import { useLocation, useNavigate } from 'react-router-dom';

/****
 * @description
    - Manages URL-based state for filters and pagination in a React app, providing functions to set, clear,
    and modify query parameters without reloading the page.

 * @functionality
    - Uses React Router's `useLocation` and `useHistory` to manipulate URL parameters,
    allowing dynamic updates to the page state based on user interactions.

 * @usage
    - @filter -> Can either be a single value or a list. Both single and list filters are strings;
      list filters are represented as comma-separated strings.
    - @setListFilters -> Accepts an array and converts it to a comma-separated string for use as a list filter. @calls navigate
    - @setFilter -> Accepts a string as an argument and sets the filter value. @calls navigate
    - @navigate -> (@internal) With a @StatefulURL setting state essentially is appending the newly updated filters to the URL
      and routing to it. The fn updates the browser's URL by appending a query string generated by @getQueryString
      to the current pathname using history.push().
    - @parseListFilterToArray -> Converts a comma-separated list string back into an array.

 * @behaviour
    - @state -> The default state includes 'limit', 'page', 'orderby', 'direction', and 'search',
      all of which are single filters. Unused filters remain null if not applicable.
    - @extraFilterKeys -> An array of obj {key: string, defaultValue?: any} that can be provided to extend the URL state with additional filters, such as 'status' in a People list. defaultValue is optional
    - @returns -> Provides the current URL state as an object along with methods for manipulating this state.
****/

const NON_FILTER_KEYS = ['limit', 'page', 'orderby', 'direction'];

export const parseListFilterToArray = filter => filter.split(',');

const defaultState = {
    limit: 25,
    page: 1,
};

function useStatefulURL(
    extraFilterKeys /* []{key: string, defaultValue?: any}, extends the url state */,
    pathName,
) {
    const location = useLocation();
    const nav = useNavigate();

    const params = useMemo(() => {
        return new URLSearchParams(location.search);
    }, [location.search]);

    const navigate = () => {
        nav(`${location.pathname}?${getQueryString()}`);
    };

    const replace = () => {
        nav(`${location.pathname}?${getQueryString()}`, { replace: true });
    };

    const clearAll = () => {
        nav(location.pathname);
    };

    const getQueryString = () => {
        return params.toString();
    };

    const applyDefaults = () => {
        for (let [key, value] of Object.entries(defaultState)) {
            params.set(key, value);
        }

        if (extraFilterKeys) {
            for (let { key, defaultValue } of extraFilterKeys) {
                //tacking on any extraFilterKeys provided to the defaults
                if (defaultValue) {
                    params.set(key, defaultValue);
                }
            }
        }

        //replaces so cant go back to an empty search url
        replace();
    };

    useEffect(() => {
        if (!location.search && pathName === location.pathname) {
            /*
            can navigate to a url with no filters and this will apply the default filters
            to the URL and replace the nav
            */
            applyDefaults();
        }
    }, [location.search, pathName, location.pathname]);

    const state = useMemo(() => {
        const value = {
            limit: params.get('limit'),
            page: params.get('page'),
            orderby: params.get('orderby'),
            direction: params.get('direction'),
            from: params.get('from'),
            to: params.get('to'),
        };
        if (extraFilterKeys) {
            for (let { key } of extraFilterKeys) {
                //tacking on any extraFilterKeys provided
                value[key] = params.get(key);
            }
        }
        return value;
    }, [params, extraFilterKeys]);

    const replaceFilter = (key, value) => {
        params.set(key, String(value));
        replace();
    };

    const setFilter = (key, value, shouldNavigate = true) => {
        if (!value) {
            // clear the param if passing value is falsey
            clearFilter(key, false);
        } else {
            params.set(key, String(value));
        }

        if (key !== 'page') {
            //if we're mutating a key other than page we need to set the page back to 1
            params.set('page', 1);
        }

        if (shouldNavigate) {
            //navigating essentially is setting state
            //optional, might want to mutate multiple values before setting state
            navigate();
        }
    };

    const clearFilter = (toDelete, shouldNavigate = true) => {
        if (typeof toDelete === 'string') {
            params.delete(toDelete);
        }
        if (Array.isArray(toDelete)) {
            for (let key of toDelete) {
                params.delete(key);
            }
        }
        if (shouldNavigate) {
            //navigating essentially is setting state
            //optional, might want to mutate multiple values before setting state
            navigate();
        }
    };

    const setListFilter = (key, values, shouldNavigate = true) => {
        if (!values || !values.length) {
            // clear the param if passing value is falsey
            clearFilter(key, shouldNavigate);
            return;
        }
        if (Array.isArray(values)) {
            //can pass an array of strings will compress to comma separated string
            setFilter(key, values.join(','), shouldNavigate);
        } else {
            //or pass comma separated string yourself
            setFilter(key, values, shouldNavigate);
        }
    };

    const setPage = value => {
        setFilter('page', value);
    };

    const setLimit = value => {
        setFilter('limit', value);
    };

    const clearSort = () => {
        setFilter('orderby', '', false);
        setFilter('direction', '');
    };

    const sortBy = (orderby, direction) => {
        setFilter('orderby', orderby, false);
        setFilter('direction', direction);
    };

    const handleDataGridSort = sortModel => {
        const [sortByObj] = sortModel;
        if (!sortByObj /* sort has been cleared */) {
            clearSort();
            return;
        }
        sortBy(
            sortByObj.field /* field name from colDefinitions is used as the filterKey */,
            sortByObj.sort,
        );
    };

    const handleDataGridPagination = paginationModel => {
        //datagrid send pagesize changes and page changes through the same method.
        const { page, pageSize } = paginationModel;
        const limit = String(pageSize);
        if (state.limit !== limit) {
            setFilter('limit', limit, false);
            setPage(1);
        } else {
            setPage(page + 1); //mui/datagrid is 0 based our API isnt
        }
    };

    const dataGridSortModel = state.orderby
        ? [{ field: state.orderby, sort: state.direction }]
        : [];

    const hasFilters = () => {
        const nonFilterValues = Object.entries(state)
            .filter(([k, _]) => !NON_FILTER_KEYS.includes(k))
            .filter(([_, v]) => !!v);

        return !!nonFilterValues.length;
    };

    const returnObj = useMemo(() => {
        return {
            state, // the current filter state
            setPage, // default filter action
            setLimit, // default filter action
            sortBy, // default filter action
            clearSort, // clear all sort filters
            setFilter, // update any filter action
            clearFilter, // clear a filter
            setListFilter, // set a list filter ([]string) => 'filter, filter, filter....'
            clearAll, // remove all filters
            getQueryString, // get the current query string
            replaceFilter, // updates a filter and does a nav.replace to replace the current URL
            parseListFilterToArray,
            hasFilters,
            navigate,

            //MUI DATAGRID
            dataGridSortModel,
            handleDataGridSort,
            handleDataGridPagination,
        };
    }, [location.search]);

    return returnObj;
}

export default useStatefulURL;
